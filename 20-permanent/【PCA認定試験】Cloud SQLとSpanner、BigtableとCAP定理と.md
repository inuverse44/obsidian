---
template: Inbox
title: 【PCA認定試験】Cloud SQLとSpanner、BigtableとCAP定理と
date: 2025-07-13
source: ソースを入れてください
tags:
  - Zenn
  - PCA
  - CloudSQL
  - CloudSpanner
  - CloudBigtable
status: archived
priority: 低
aliases:
---
## はじめに
GCPのDBを勉強していると、「Cloud SQLやSpannerは一貫性を重視したCPシステム」という話をよく聞きますよ。初心者としては「可用性を優先したAPシステムは？」「CAシステムってないの？」という疑問が自然と湧いてくるはずです。

この記事では、そんな自然な問いについて調べてみました。PCA認定試験でも、特定の状況におけるDBを選定する問題はよくあるので、DB選定に制限を課すCAP定理という側面から問題を見ていこうと思います

最終的に、下記のような図の意味がわかるようになります。
![](https://storage.googleapis.com/zenn-user-upload/1a8197c7cdbc-20250713.png)


---

## CAP定理の簡単なおさらい

簡単なおさらいです。

- $C$ (Consistency: 一貫性)：いつ、どのサーバーに聞いても、みんなが「最新データはコレです」と同じ答えを返してくれる状態。
- $A$ (Availability: 可用性)：サーバーに「データくれや」とリクエストしたら、とりあえず何かしら（エラーじゃなく）返事をくれる状態。無視されないこと。
- $P$ (Partition Tolerance: 分断耐性)：サーバー間の通信が急に切れても、システムがなんとか動き続けられるタフさ。

$CAP$定理の主な主張とは、上記$CAP$を同時に満たすようなDBは存在しないという、いわゆるNo-go theoremです。
すなわち、考えうるDBは$C$、$A$、$P$を独立に満たすものと、2つの要素の組み合わせである$CA$（一貫性＋可用性）、$AP$（可用性＋分断耐性）、 $PC$（分断耐性＋一貫性）の6通りにDBは属すると考えることができます。現実問題、満たす項目が多いほど嬉しいので、下記では$CA, AP, PC$の3つを考えます。

はじめに言及しますが、クラウドのような分散システムでは、ネットワーク分断（$P$）は避けて通れないません。そこで、$CAP$定理とは言っているものの、基本的には**Pが起きた時、CとAのどっちを優先するのか**ということが必然的に求められます。



---

## CAP定理の証明
実際に[1]を読んで、該当の箇所を追ってみました。一部略してあります。

**定理:**
非同期ネットワークモデルにおいて、次の性質を保証するread/writeデータオブジェクトを実装することは不可能である。

- 可用性 (Availability)
- 原子一貫性 (Atomic consistency)

これは、メッセージが失われる場合を含む、すべての実行 (fair execution)においてである。

※現代的にはACID特性という言葉があるように、原子性と一貫性は分けて書くべきなのでしょうかね？ちなみに、
- 原子性(Atomicity):
トランザクション内のすべての操作が成功するか、または一つも実行されないかのどちらかであることを保証
- 一貫性(Consistency):
トランザクションの前後で、DBが整合性制約を満たしていることを保証
- 独立性(Isolation):
複数のトランザクションが同時に実行されても、互いに干渉しないように独立性を保証
- 永続性(Durability):
トランザクションが成功した場合、その結果がシステム障害などが発生しても失われないことを保証

であることをまとめておきます。下記も参考にしてください。
https://qiita.com/RyutoYoda/items/0cd43432e8c7bcb5c028#:~:text=ACID%E3%81%A8%E3%81%AF%E3%80%81%E3%83%87%E3%83%BC%E3%82%BF%E3%83%99%E3%83%BC%E3%82%B9%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B6%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3,%E6%8C%81%E7%B6%9A%E6%80%A7%EF%BC%89%20%E3%82%92%E6%8C%87%E3%81%97%E3%81%BE%E3%81%99%E3%80%82

**雑な証明:**
基本的にCAP全てを満たすこと仮定して、矛盾を導く方針です。まず$P$でネットワークを分断させておいて、読み込み操作・書き込み操作の一連の操作の結果を考察します。

設定
- $G_1, G_2$: ネットワーク分断で独立したノードです。例えば、サーバーやコンテナ、Kubernatesのポッドを指します。
- $\alpha_1$: $v_0$という値をそれ以外（例えば$v_1$）に変更する操作を実行すること。書き込み操作。
- $\alpha_2$:　読み込み操作。DBに何の値が入っているかを取得する。

![](https://storage.googleapis.com/zenn-user-upload/23e51372f846-20250713.png)

これを図解すると上記のようなイメージです。$P$の要請から、ノードが分断されてもシステムは稼働を続けます。この時点ではどちらのDBにも$v_0$が入っているわけです。次に、$G_1$に対して$\alpha_1$を実施し、$G_2$に対して$\alpha_2 (\neq \alpha_1)$を実施します。この操作は$A$から必ず成功しなければなりません。しかし、成功するが故に、$G_1$のDBには$v_0$ではない値、$G_2$のDBには$v_0$が格納されています。ゆえに、$C$が破綻してしまうわけです。

このようにして$CAP$が成り立つ元、ある特定の状況（ネットワークの分断）において、$C$が破れるという反例が見つかりました。すなわち、$CAP$という最初において仮定が間違いであり、私たちは常に$CA, AP, PC$のどれかを選ぶ必要があるわけです。完璧なシステムが存在せず、常にトレードオフを考える必要があることの示唆を提示しています。

### 参考：
とここまでCAPについて説明してきましたが、現実問題、そこまで単純化もできないですし、調べたところ分散システムの設定にも不備があるという指摘もありました。そもそも$CAP$の定義が論文によって違うこともあるそうです。

https://cir.nii.ac.jp/crid/1572543027745543808

CAP定理をより詳細にしたものでPACELC定理という考え方があるそうです：

>If a **P**artition occurs, choose between **A**vailability and **C**onsistency.
**E**lse (in normal operation), choose between **L**atency and **C**onsistency.

D. J. Abadi (2012)
https://ieeexplore.ieee.org/document/6127847
分断時$P$ではない平時のときに、低レイテンシか一貫性のどちらを取るかを考慮にいれたそうですが、まだ読めていません。おいおい読みたいものですね。

最も参考にした論文です。全ては読めていませんが、このような分野もあるのだなと勉強になりました。
S. Gilbert and N. Lynch (2002)
https://users.ece.cmu.edu/~adrian/731-sp04/readings/GL-cap.pdf

もともとの$CAP定理$の提唱者のE. BrewerがCAP定理が証明されてから10年後にコメントを残しています。
::::details Geminiによる回答
#### 「3つのうち2つを選ぶ」は誤解である
Brewerが最も伝えたかったことです。CAP定理は、システム設計を「$CP$か$AP$か」という二者択一で考える単純なものではないと彼は言います。

常にトレードオフが発生するわけではない: ネットワークが正常なとき（分断$P$が起きていないとき）は、当然ながら一貫性$C$と可用性$A$は両立できます。問題は、分断が起きた「ときだけ」です。

分断は実はまれ: 現実の多くのシステム、特に同一データセンター内で完結するシステムでは、深刻なネットワーク分断はまれなイベントです。そのため、「100%の可用性」か「100%の一貫性」か、という極端な選択をする必要はほとんどありません。

#### トレードオフは「度合い（グラデーション）」の問題
$CAP$の選択は「0か100か」ではありません。実際には、どの程度の一貫性を犠牲にして、どの程度の可用性を得るか、という「グラデーション」で考えるべきだと述べています。

遅延時間も考慮に入れる: 例えば、「50ミリ秒以内に応答がなければ、それは分断とみなして可用性を優先する」といった設計が可能です。これは、応答時間という「可用性（$A$）」の質と、「一貫性（$C$）」を天秤にかけていることになります。

全てか無かではない: 分断が起きた際も、システムの機能を全て停止する必要はありません。「在庫の確認はできる（読み取りはOK）が、購入はできない（書き込みはNG）」のように、操作によってCとAの扱いを変えることができます。

#### 分断時の「計画的な復旧」が重要
分断はいつか必ず回復します。重要なのは、分断が起きたときにどう振る舞い、回復したときにどうやって矛盾を解消するかという計画です。

不変条件の管理: システムが絶対に守らなければならない条件（例えば、「銀行口座の残高はマイナスにならない」など）を定義し、分断時もその条件が破られないように操作を制限します。

矛盾の解消: 意図的に矛盾を許容した場合（例えば、飛行機のオーバーブッキングのように）、後でそれをどう解消するか（補償金を支払う、フライトを振り替えるなど）のビジネスロジックを準備しておくことが重要です。
::::

https://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed/



## CP (一貫性 > 可用性) の代表：Cloud SQL & Spanner

これは「データの正確さが何よりも大事！」という考え方のグループです。

- **Cloud SQL (HA: High Availability構成)**: リージョン内のゾーンが分断された場合、「矛盾したデータを返すくらいなら、数分間サービスを止めてでも、正しい状態に復旧する！」という選択をします。これがフェイルオーバーです。小規模ながらも、非常にわかりやすいCPシステムですね。

- **Cloud Spanner**: 地球規模で「データの矛盾は絶対に許さない」という強い意志を持っています。その上で、独自の技術（原子時計とか）を駆使して、可用性を極限まで高めています。しかし、大規模な分断が起きてデータの合意形成（クォーラム）が取れない場合は、やはり一貫性を守るために書き込みをエラーにします。つまり、究極的に洗練されたCPシステムというわけです。

https://cloud.google.com/spanner/docs/true-time-external-consistency?hl=ja

---

## AP (可用性 > 一貫性) の代表：Cloud Bigtable

次に「どんな時でも、とにかくリクエストに応え続けるのが使命！」という考え方のグループです。GCPでは、**Cloud Bigtable**がその代表格です。

### アーキテクチャとCAP定理の挙動

Bigtableは、IoTのセンサーデータや分析ログなど、超大量のデータを高速に書き込み・読み込みするために設計されたNoSQLです。

- **整合性モデル:** Bigtableの整合性は、基本的に結果整合性 (Eventual Consistency) です。
- **AP的な挙動:**
    1. あるクライアントがBigtableのあるノードに新しいデータを書き込みます。
    2. そのデータがクラスタ内の全ノードにコピーされるには、ほんのわずかな時間（ミリ秒単位）がかかります。
    3. もし、その瞬間に別のクライアントがまだコピーされていないノードにデータを読み取りに行くと、システムは古いデータを返します。

これは、一貫性$C$を少し犠牲にしてでも、リクエストに対して即座に応答する（$A$）ことを優先しているからです。「ちょっと古いデータかもしれんけど、応答しないよりマシやろ？」というのがBigtableのスタンスだと考えています。

**🔵 PCA試験における位置づけ:**
大量の書き込みスループットが求められ、かつ、最新のデータがミリ秒単位で反映されなくても問題ないユースケース（例：IoTデータ収集、時系列分析、広告配信のバックエンドなど）で最適な選択肢となります。

---

## CA (一貫性 & 可用性) について

「じゃあ、究極のCAシステムは？」という最後の疑問。

Brewerの指摘の通り、**現実の分散システムにおいて、純粋なCAは存在しない**と考えられています。

なぜなら、クラウド上で動くDBは、複数のサーバーやネットワーク機器から構成される分散システムであり、ネットワーク分断（P）の可能性をゼロにはできないからです。そして、CAP定理が示す通り、Pを許容した瞬間にCとAはトレードオフの関係になります。

理論上、ネットワークから完全に切り離された単一のマシンで動くDBだけがCAと言えますが、それはクラウドサービスが提供する価値（スケーラビリティや耐障害性）とは相容れません。

「Spannerは実質CAでは？」と聞かれることもありますが、前述の通り、Spannerはあくまで極限まで可用性を高めたCPシステムと理解するのが正確かなと思います。

---

## まとめ：PCA試験に向けたDB選択フロー

CAP定理を理解すると、GCPのDBを以下の様なフローで考えられるようになります。

1.  あなたのアプリは、データの強い一貫性が必要ですか？それとも可用性/スループットが最優先ですか？

    - A:「強い一貫性！」が最優先の場合 (CPを選択)
        - アプリは**単一リージョン**で動きますか？ → **Cloud SQL**
        - **グローバル展開**が必要で、世界中で一貫したデータが必要ですか？ → **Cloud Spanner**

    - B:「可用性/スループット！」が最優先で、結果整合性でOKな場合 (APを選択)
        - **超大規模**なデータ（テラ〜ペタバイト級）を扱いますか？ → **Cloud Bigtable**

このシンプルな判断軸こそ、PCA試験のシナリオ問題でDBを選択する際の強力な武器になります。それぞれのサービスが$CAP$定理のどの位置にいるかを意識して、最適なアーキテクチャを設計しましょう！

最後に、CPA定理における、上記３サービス（Cloud SQL, Spanner, Bigtable）を（冒頭でも紹介したものですが）図として与えておきます！

![](https://storage.googleapis.com/zenn-user-upload/1a8197c7cdbc-20250713.png)


# 🔗 関連
- [[GCPの沼：限定公開のGoogleアクセス(PGA)とEgress全拒否ファイアウォールが引き起こすタイムアウト地獄]]
- [[待ち行列理論で見るGKEのポッド数最適化]]




